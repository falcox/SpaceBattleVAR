class CollisionDetector{
	var ambientSpaceshipNum;
	var enemyFighterNum;
	var network;
	
	CollisionDetector(aNum, eNum, net);
	checkCollisionBBox(myFighter, enemyArray, ambientArray);
	checkCollisionDeep(myFighter, shipObj);
//	checkWorldBounds(myFighter);
};

function CollisionDetector::CollisionDetector(aNum, eNum, net) {
	ambientSpaceshipNum = aNum;
	enemyFighterNum = eNum;
	network = net;
}

function CollisionDetector::checkCollisionBBox(myFighter, enemyArray, ambientArray){
	var changed = false;
	var myFighterObj = myFighter.getObject();
	var aliveBeamsNum = myFighter.getAliveBeamsNum();
	var aliveBeams = myFighter.getAliveBeams();						//array con gli indici dei bullet vivi
	var enemyBeams;
	for (var i = 0; i < enemyFighterNum; i++) {
		if (enemyArray[i] != void) {
			if(myFighterObj.isCollidingBBox(enemyArray[i].getObject())){
				myFighter.setCollision(true); 
				changed = true;
			}
			for(var j = 0; j<aliveBeamsNum; j++){
				var beam = myFighter.getBeam(AliveBeams[j]);
				if(beam.isCollidingBBox(enemyArray[i].getObject())){
					//TODO: gestisci la hit dei nemici
					beam.setCollided();
					outputln("Hit enemy!");
				}
			}
			enemyBeams = enemyArray[i].getAliveBeams();
			for(var j = 0; j<len(enemyBeams); j++){
				var beam = enemyArray[i].getBeam(enemyBeams[j]);
				if(beam.isCollidingBBox(myFighter)){
					myFighter.decreaseLife(beam.getDamage());
					
					beam.setCollided();
					outputln("I've been hit!");
				}
			}
		}
	}
	for (var i = 0; i < ambientSpaceshipNum; i++) {
		if (ambientArray[i] != void ) {
			var shipObj = ambientArray[i].getObject();
			if(myFighterObj.isCollidingBBox(shipObj)){
				if(ambientArray[i].isDestroyable()){
					ambientArray[i].setCollision(true);
					network.sendAmbientDestroyData(i, -1);
				} else {
					changed = changed || checkCollisionDeep(myFighter, shipObj);
				}
			}
			for(var j = 0; j<aliveBeamsNum; j++){
				var beam = myFighter.getBeam(AliveBeams[j]);
				if(beam.isCollidingBBox(shipObj)){
					if(ambientArray[i].isDestroyable()){
						ambientArray[i].setCollision(true);
						network.sendAmbientDestroyData(i, -1);					
					}
					beam.setCollided();
					outputln("bullet collided");
				}
			}
		}
	}
	if(!changed){
		myFighter.setCollision(false);
	}
}

function CollisionDetector::checkCollisionDeep(myFighter, shipObj) {
	var pos = myFighter.getPosition();
	for(var j = 0; j < 6; j+=2) {
		if(shipObj.isColliding(pos+myFighter.getCollVertex()[j+1],pos+myFighter.getCollVertex()[j])) {
			myFighter.setCollision(true); 
			//myFighter.setCollisionInfo(collisionInfo);
			return true;
		}
	}
	return false;
}

/*function CollisionDetector::checkWorldBounds(myFighter){
	var fighterPos = myFighter.getPosition();
	var fighterDir = myFighter.getDirection();
	var tmpDir = Vector(3);
	if(((fighterPos.x>=BOUND_VOLUME_X) && (fighterDir.x>0)) || ((fighterPos.x<=-BOUND_VOLUME_X) && (fighterDir.x<0))){
		tmpDir.x = 0;
	}else{
		tmpDir.x = fighterDir.x;
	}
	if(((fighterPos.y>=BOUND_VOLUME_Y) && (fighterDir.y>0)) || ((fighterPos.y<=-BOUND_VOLUME_Y) && (fighterDir.y<0))){
		tmpDir.y = 0;
	}else{
		tmpDir.y = fighterDir.y;
	}
	if(((fighterPos.z>=BOUND_VOLUME_Z) && (fighterDir.z>0)) || ((fighterPos.z<=-BOUND_VOLUME_Z) && (fighterDir.z<0))){
		tmpDir.z = 0;
	}else{
		tmpDir.z = fighterDir.z;
	}
	myFighter.setDirection(tmpDir);
}*/
